<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Display File</title>
</head>

<style>

    .node rect {
      fill: #fff;
      stroke: steelblue;
      stroke-width: 3px;
    }
    
    .node text {
      font: 12px sans-serif;
    }
    
    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }
    
</style>
    
<body>
    <div id="tree-container"></div>
    <script src="../../static/sbom_viz/js/fileDisplayPage.js" type="module"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>

      /*
       * Credit: 
       * Collapsible tree diagram in v7
       * by d3noob
       * (https://gist.github.com/d3noob/918a64abe4c3682cac3b4c3c852a698d)
       * An interactive version of a Reingoldâ€“Tilford tree. Click on the nodes to expand or collapse.
       * by Mike Bostock
       * (https://gist.github.com/mbostock/4339083)
       * With some changes to each to allow for:
       *    JSON file input,
       *    and Vertical orientation
       */

        var treeData =
          {
            "name": "Top Level",
            "children": [
              { 
                "name": "Level 2: A",
                "children": [
                  { "name": "Son of A" },
                  { "name": "Daughter of A" }
                ]
              },
              { "name": "Level 2: B" }
            ]
          };
        
        // Set the dimensions and margins of the diagram
        var margin = {top: 50, right: 90, bottom: 30, left: 90},
            width = 1000 - margin.left - margin.right,
            height = 1000 - margin.top - margin.bottom;
        
        // append the svg object to the body of the page
        // appends a 'group' element to 'svg'
        // moves the 'group' element to the top left margin
        var svg = d3.select("body").append("svg")
        .attr("id", "tree-svg")
        .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate("
                  + margin.left + "," + margin.top + ")");
        
        var i = 0,
            duration = 750, // in milliseconds
            root;

        let node_width = 200;
        let node_height = 100;
        
        // declares a tree layout and assigns the size
        var treemap = d3.tree().nodeSize([node_width,node_height])//size([height, width]);
        
        // Assigns parent, children, height, depth
        // Currently loads JSON data from this link,
        // The commented out line below would allow it to use the
        // Raw JSON defined in this file
        d3.json("http://127.0.0.1:8000/data.json").then(function(data){
            root = d3.hierarchy(data, function(d){return d.children;});
            //root = d3.hierarchy(treeData, function(d) { return d.children; });
            root.x0 = height / 2;
            root.y0 = 0;
            
            // Collapse after the second level
            root.children.forEach(collapse);
            
            update(root);
            resizeCanvas();
            
            // Collapse the node and all it's children
            function collapse(d) {
                if(d.children) {
                    d._children = d.children
                    d._children.forEach(collapse)
                    d.children = null
                }
            }
        });

        function update(source) {
        
          // Assigns the x and y position for the nodes
          var treeData = treemap(root);
        
          // Compute the new tree layout.
          var nodes = treeData.descendants(),
              links = treeData.descendants().slice(1);
        
          // Normalize for fixed-depth.
          nodes.forEach(function(d){ d.y = d.depth * 90});
        
          // ****************** Nodes section ***************************
        
          // Update the nodes...
          var node = svg.selectAll('g.node')
              .data(nodes, function(d) {return d.id || (d.id = ++i); });
        
          // Enter any new modes at the parent's previous position.
          var nodeEnter = node.enter().append('g')
              .attr('class', 'node')
              .attr("transform", function(d) {
                return "translate(" + source.x0 + "," + source.y0 + ")";
            })
            .on('click', click);

          var rectHeight = 60, rectWidth = 120;
        
          // Add rectangle for the nodes
          nodeEnter.append('rect')
              .attr('class', 'node')
              .attr('width', rectWidth)
              .attr('height', rectHeight)
              .attr('x', 0)
              .attr('y', (rectHeight/2)*-1)
              .attr('rx', '5')
              .style("fill", function(d) {
                  return d._children ? "lightsteelblue" : "#fff";
              });
        
          // Add labels for the nodes
          nodeEnter.append('text')
              .attr("dy", ".35em")
              .attr("x", function(d) {
                  return d.children || d._children ? -13 : 13;
              })
              .attr("text-anchor", function(d) {
                  return d.children || d._children ? "end" : "start";
              })
              .text(function(d) { return d.data.name; });
        
          // UPDATE
          // Extra styling is from:
          // https://observablehq.com/@bumbeishvili/vertical-collapsible-tree
          var nodeUpdate = nodeEnter.merge(node)
            .attr("fill", "#fff")
            .attr("stroke", "steelblue")
            .attr("stroke-width", "3px;")
            .style('font', '12px sans-serif');
        
          // Transition to the proper position for the node
          nodeUpdate.transition()
            .duration(duration)
            .attr("transform", function(d) { 
                return "translate(" + d.x + "," + d.y + ")";
             });
        
          // Update the node attributes and style
          nodeUpdate.select('rect.node')
            .attr('r', 10)
            .style("fill", function(d) {
                return d._children ? "lightsteelblue" : "#fff";
            })
            .attr('cursor', 'pointer');
        
        
          // Remove any exiting nodes
          var nodeExit = node.exit().transition()
              .duration(duration)
              .attr("transform", function(d) {
                  return "translate(" + source.x + "," + source.y + ")";
              })
              .remove();
        
          // On exit reduce the node rectangle size to 0
          nodeExit.select('rect')
            .attr('r', 1e-6);
        
          // On exit reduce the opacity of text labels
          nodeExit.select('text')
            .style('fill-opacity', 1e-6);
        
          // ****************** links section ***************************
        
          // Update the links...
          var link = svg.selectAll('path.link')
              .data(links, function(d) { return d.id; });
        
          // Enter any new links at the parent's previous position.
          var linkEnter = link.enter().insert('path', "g")
              .attr("class", "link")
              .attr('d', function(d){
                var o = {x: source.x0, y: source.y0}
                return diagonal(o, o)
              });
        
          // UPDATE
          // Extra styling is from: 
          // https://observablehq.com/@bumbeishvili/vertical-collapsible-tree
          var linkUpdate = linkEnter.merge(link)
            .attr("fill", "none")
            .attr("stroke", "#ccc")
            .attr("stroke-width", "2px");
        
          // Transition back to the parent element position
          linkUpdate.transition()
              .duration(duration)
              .attr('d', function(d){ return diagonal(d, d.parent) });
        
          // Remove any exiting links
          var linkExit = link.exit().transition()
              .duration(duration)
              .attr('d', function(d) {
                var o = {x: source.x, y: source.y}
                return diagonal(o, o)
              })
              .remove();
        
          // Store the old positions for transition.
          nodes.forEach(function(d){
            d.x0 = d.x;
            d.y0 = d.y;
          });
        
          // Creates a curved (diagonal) path from parent to the child nodes
          function diagonal(s, d) {
        
            const path = `M ${s.x} ${s.y}
                          C ${(s.x + d.x) / 2} ${s.y},
                            ${(s.x + d.x) / 2} ${d.y},
                            ${d.x} ${d.y}`
            return path
          }
        
          // Toggle children on click.
          function click(event, d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
              } else {
                d.children = d._children;
                d._children = null;
              }
            update(d);
            resizeCanvas();
          }
        }

        function resizeCanvas() {
          
          let svg = document.getElementById("tree-svg");
          let newDimensions = svg.getBBox();
          let frequentResize = setInterval(singleResize, 10); // Fix canvas size every 10 milliseconds
          setTimeout(() => {clearInterval(frequentResize)}, duration);

          function singleResize() {
            console.log("Resize");
            // Resize the svg to fit all components
            let svg = document.getElementById("tree-svg");
            let newDimensions = svg.getBBox();
            console.log(newDimensions);
            svg.setAttribute("x", newDimensions.x);
            svg.setAttribute("y", 0);
            svg.setAttribute("width", newDimensions.width + margin.left + margin.right);
            svg.setAttribute("height", newDimensions.height + margin.top + margin.bottom);
          }
        }
        
        </script>

</body>
</html>