import xmltodict

class CycloneDxXmlParser():
    """
    This class is used to parse an uploaded sbom file and provides accessor methods
    for information needed by other parts of the application.
    """
    def __init__(self):
        """Initialize parser attributes to store important information"""
        self.sbom_dict = {}
        self.version = ""
        self.components_list = []
        self.relationship_list = []
        self.id_data_map = {}
        self.license_frequency_map = {}
        self.id_license_map = {}
        self.purl_id_map = {}

    def add_to_licenses_frequency_map(self, license_string):
        """
        This function is to be called from parse_licensing_information. It handles the logic for either adding a new license to the 
        frequency map or increment the license's corresponding value if it is already present.
        """
        if (license_string not in self.license_frequency_map):
            self.license_frequency_map[license_string] = 1
        else:
            self.license_frequency_map[license_string] += 1

    def add_to_id_license_map(self, id, license): 
        """
        This function is a helper function to be called from parse_license_information(). It can be modified to change how the application
        processes components with multiple license definitions. As of now, duplicates are ignored.
        """
        ignore_count = 0
        if (id in self.id_license_map and license != self.id_license_map[id]): # True when an id already has a license stored that is different from the passed in license
            ignore_count += 1 
        elif (id not in self.id_license_map): 
            self.id_license_map[id] = license
        return ignore_count

    def parse_licensing_information(self):
        """
        This function fills self.license_frequency_map and self.id_data_map with sbom component data.
        It is only intended to be called by self.parse_file().
        """
        pass

    def find_version(self):
        """
        Determine the version of SPDX and store it as a string in self.version.
        It is only intended to be called by self.parse_file().
        """
        pass

    def translate_and_add_component_to_dict(self, component, dict):
        """
        This function translates some of the quirks of the attribute keys generated by the combination of xmltodict and cyclonedx into our
        abstract representation of an sbom component and add populates the provided dictionary with the components information under new 
        attribute names.
        """
        try:
            for key in component:
                match key:
                    case "@bom-ref":
                        dict["id"] = component[key]
                    case "@type":
                        dict["type"] = component[key]
                    case _:
                        dict[key] = component[key]
            if "@bom-ref" not in component:
                dict["id"] = component["name"]
        except Exception as e:
            print(f"{e}\nException occurred in cyclonedx_parser -> translate_and_add_component_to_dict()")

    def parse_document_information(self):
        """
        This function adds a dictionary representing the metadata describing the sbom document itself to 
        self.components_list.
        It is only intended to be called by self.parse_file().
        """
        document = {}
        try:
            current_target = self.sbom_dict['bom']['metadata']
            for key in current_target.keys():
                if key == "component":
                    self.translate_and_add_component_to_dict(current_target[key], document)
                else:
                    document[key] = current_target[key]
        except Exception as e: # Happens if the data fails to parse or the metadata isn't present.
            pass
        if len(document) < 1:
            document['id'] = "No metadata component"
        self.components_list.append(document)

    def parse_component_information(self):
        """
        This function adds the remainder of the components to self.components_list. 
        It is only intended to be called by self.parse_file(), and after self.parse_document_information().
        """
        try:
            components = self.sbom_dict['bom']['components']['component']
            for component in components:
                #print(component)
                component_dict = {}
                self.translate_and_add_component_to_dict(component=component, dict=component_dict)
                self.components_list.append(component_dict)
        except Exception as e:
            pass

    def parse_relationship_information(self):
        """
        This function fills self.relationship_list
        """
        relationship_list = []
        try:
            dependencies = self.sbom_dict['bom']['dependencies']['dependency']
            for dependency_entry in dependencies:
                if "dependency" in dependency_entry: # False if the current dependency entry refers to a component with no dependencies
                    target_id = dependency_entry['@ref']
                    relationship_type = "dependsOn"
                    if isinstance(dependency_entry['dependency'], list): # Components with multiple dependencies have their reference ids stored in a list 
                        for child in dependency_entry['dependency']:
                            relationship = {}
                            relationship['target_id'] = target_id
                            relationship["type"] = relationship_type
                            relationship['source_id'] = child['@ref']
                            relationship_list.append(relationship)
                    else:
                        relationship = {}
                        relationship['target_id'] = target_id
                        relationship["type"] = relationship_type
                        relationship['source_id'] = dependency_entry['dependency']['@ref']
                        relationship_list.append(relationship)

        except Exception as e: 
            # This runs on old CycloneDX versions like 1.1 with no dependencies
            pass
            #print("\n\n\n\nException in cyclonedx_xml_parser.py -> parse_relationship_information() \n\n\n")
        self.relationship_list = relationship_list


    def parse_id_to_data_map(self):
        """
        This function defines the logic for building the id-to-data dictionary which allows the Front-End code to acquire a component's 
        data from the id it is provided by the tree JSON object. 
        This function is only intended to be called from parse_file(). 
        get_id_data_map() should be used to acquire the dictionary object after a file is parsed. 
        """
        for component in self.components_list:
            try :
                self.id_data_map[component['id']] = component
            except Exception:
                pass
    
    def parse_purl_to_id_map(self):
        """
        This function generates the purl-to-id mapping which is used to determine which component a security vulnerability is associated
        with.
        This function is only intended to be called from parse_file(). It needs to be called after parse_components().
        """
        pass

    def parse_file(self, file_string):
        self.sbom_dict = xmltodict.parse(file_string)
        self.find_version()
        self.parse_document_information()
        self.parse_component_information()
        self.parse_licensing_information()
        self.parse_relationship_information()
        self.parse_id_to_data_map()
        self.parse_purl_to_id_map()

    def get_components(self):
        return self.components_list
    
    def get_relationships(self):
        return self.relationship_list
    
    def get_id_data_map(self):
        return self.id_data_map
    
    def get_license_information(self):
        """Return license information in a format requested by the front-end team."""
        license_info = {}
        license_info['distribution'] = self.license_frequency_map
        license_info['mapping'] = self.id_license_map
        return license_info
    
    def get_purl_id_map(self):
        return self.purl_id_map